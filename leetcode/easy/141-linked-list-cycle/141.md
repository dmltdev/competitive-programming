# Linked List Cycle Detection

## Problem Restatement

Given the head of a singly linked list, determine whether the list contains a cycle. A cycle exists if a node can be reached again by continuously following the next pointer. Return true if a cycle exists, false otherwise.

**Inputs:** Head of a linked list (could be null)
**Output:** Boolean indicating presence of a cycle
**Constraints:** Nodes may point back to any previous node, creating a loop

## Pattern Recognition

**Problem Category:** Linked List Traversal with Cycle Detection

**Structural Properties:**
- We cannot use indices because linked lists lack random access
- We cannot count nodes because a cycle makes the list infinite
- We must detect if traversal returns to a previously visited node

**Algorithmic Pattern:** Floyd's Cycle Detection (Two Pointers - Fast and Slow)

**Key Insight:** If a cycle exists, a faster pointer will eventually lap a slower pointer within the cycle. This is similar to two runners on a circular track - the faster runner will eventually catch up to the slower one.

**Related Problems:**

1. **Linked List Cycle II** (LeetCode 142)
   - Same pattern but requires finding the node where the cycle begins
   - Uses Floyd's algorithm plus mathematical property: distance from head to cycle start equals distance from meeting point to cycle start

2. **Happy Number** (LeetCode 202)
   - Detects cycles in a sequence of number transformations
   - Uses same two-pointer technique on implicit linked list structure

3. **Find the Duplicate Number** (LeetCode 287)
   - Array treated as linked list where arr[i] points to arr[arr[i]]
   - Cycle detection reveals the duplicate

4. **Intersection of Two Linked Lists** (LeetCode 160)
   - Uses two-pointer technique for convergence detection
   - Different variation but same core concept of pointer movement rates

## Multiple Approaches

### Approach 1: Hash Set (Baseline)

**Intuition:** Track every node we visit. If we visit a node twice, a cycle exists.

**Time Complexity:** O(n) - visit each node once
**Space Complexity:** O(n) - store all visited nodes

**Inefficiencies:**
- Requires extra space proportional to list size
- Hash operations have overhead
- Not optimal for space-constrained environments

### Approach 2: Floyd's Cycle Detection (Optimal)

**Intuition:** Use two pointers moving at different speeds. If they meet, a cycle exists.

**Time Complexity:** O(n) - in worst case, pointers traverse the cycle multiple times but still linear
**Space Complexity:** O(1) - only two pointers

**Why this is optimal:** Achieves the same time complexity as the hash set approach while using constant space. No better space complexity is possible since we need at least two pointers to track position.

### Approach 3: Brent's Algorithm (Alternative Optimal)

**Intuition:** Use teleporting pointer strategy instead of continuous movement.

**Time Complexity:** O(n) - potentially 25-30% fewer iterations than Floyd's
**Space Complexity:** O(1) - two pointers

**Tradeoff:** More complex to implement and understand. Offers marginal performance gain in practice. Floyd's is industry standard due to simplicity.

## Optimized Approach Deep Dive

I will focus on Floyd's Cycle Detection as it is the most widely used optimal solution.

### Key Insight

In a cycle, two pointers moving at different speeds must eventually meet. The fast pointer moves 2 steps while the slow pointer moves 1 step. If a cycle exists, the fast pointer will enter the cycle first and eventually catch the slow pointer from behind.

**Mental Shift from Hash Set:** Instead of remembering where we have been (space cost), we use pointer movement physics to detect revisiting.

### Algorithm Properties

**Invariants maintained:**
- Slow pointer advances 1 node per iteration
- Fast pointer advances 2 nodes per iteration
- If no cycle exists, fast pointer reaches null
- If cycle exists, fast pointer enters cycle before slow pointer
- Once both are in the cycle, the gap between them decreases by 1 each iteration

**Key property:** In a cycle of length C, if the fast pointer is k nodes behind the slow pointer, it catches up in exactly k iterations (closes gap by 1 per iteration).

### Implementation Walkthrough

**Step 1: Initialize both pointers at head**
- Start both slow and fast at the same position

**Step 2: Move pointers at different speeds**
- Slow moves 1 step: `slow = slow.next`
- Fast moves 2 steps: `fast = fast.next.next`

**Step 3: Check for termination conditions**
- If fast reaches null (no next or next.next), no cycle exists
- If slow equals fast, cycle detected

**Step 4: Handle edge cases**
- Empty list (head is null) → no cycle
- Single node → check if it points to itself

### Step-by-Step Example

**Example 1: Cycle exists**

```
List: 1 → 2 → 3 → 4 → 5
              ↑_______↓

Initial: slow = 1, fast = 1

Iteration 1:
  slow = 2 (moved 1 step)
  fast = 3 (moved 2 steps)
  
Iteration 2:
  slow = 3
  fast = 5

Iteration 3:
  slow = 4
  fast = 4 (fast went 5→3→4, wrapping around)
  slow === fast → CYCLE DETECTED
```

**Example 2: No cycle**

```
List: 1 → 2 → 3 → null

Initial: slow = 1, fast = 1

Iteration 1:
  slow = 2
  fast = 3
  
Iteration 2:
  slow = 3
  fast.next.next = null
  Loop exits → NO CYCLE
```

**Example 3: Single node pointing to itself**

```
List: 1 ⟲

Initial: slow = 1, fast = 1

Iteration 1:
  slow = 1 (slow.next points back to 1)
  fast = 1 (fast.next.next points back to 1)
  slow === fast → CYCLE DETECTED
```

## Implementation

### Hash Set Approach

```typescript
function hasCycleHashSet(head: ListNode | null): boolean {
  const visited = new Set<ListNode>();
  let current = head;
  
  while (current !== null) {
    if (visited.has(current)) {
      return true; // Found a node we have already visited
    }
    visited.add(current);
    current = current.next;
  }
  
  return false; // Reached end of list without revisiting any node
}
```

### Floyd's Cycle Detection (Optimal)

```typescript
function hasCycle(head: ListNode | null): boolean {
  // Edge case: empty list has no cycle
  if (head === null) {
    return false;
  }
  
  let slow: ListNode | null = head;
  let fast: ListNode | null = head;
  
  // Continue while fast pointer can move 2 steps ahead
  while (fast !== null && fast.next !== null) {
    slow = slow!.next;           // Move slow pointer 1 step
    fast = fast.next.next;       // Move fast pointer 2 steps
    
    if (slow === fast) {
      return true; // Pointers met, cycle exists
    }
  }
  
  return false; // Fast pointer reached end, no cycle
}
```

### Brent's Algorithm (Alternative)

```typescript
function hasCycleBrent(head: ListNode | null): boolean {
  if (head === null) {
    return false;
  }
  
  let tortoise: ListNode | null = head;
  let hare: ListNode | null = head.next;
  let power = 1;
  let lambda = 1;
  
  // Find the cycle length (lambda)
  while (hare !== null && tortoise !== hare) {
    if (lambda === power) {
      tortoise = hare; // Teleport tortoise to hare's position
      power *= 2;       // Double the check distance
      lambda = 0;
    }
    hare = hare.next;
    lambda++;
    
    if (hare === null) {
      return false; // Reached end without cycle
    }
  }
  
  return hare !== null; // If hare is not null, we found a cycle
}
```

## Edge Cases, Testing, and Common Mistakes

### Edge Cases and Testing

```
Empty list: head = null → false (no nodes, no cycle)
Single node, no cycle: 1 → null → false
Single node, self-loop: 1 ⟲ → true (node points to itself)
Two nodes, no cycle: 1 → 2 → null → false
Two nodes, cycle to first: 1 ⇄ 2 → true
Cycle at middle: 1 → 2 → 3 → 4 → 5 → (back to 3) → true
Cycle at end: 1 → 2 → 3 → (3 points to itself) → true
Large list no cycle: 10000 nodes → null → false (performance check)
```

### Common Mistakes

**Mistake 1: Incorrect null checks**
```typescript
// WRONG: Not checking fast.next before accessing fast.next.next
while (fast !== null) {
  fast = fast.next.next; // Crashes if fast.next is null
}

// CORRECT: Check both fast and fast.next
while (fast !== null && fast.next !== null) {
  fast = fast.next.next;
}
```

**Mistake 2: Starting with wrong initial positions**
```typescript
// WRONG: Starting fast pointer ahead
let slow = head;
let fast = head.next; // This changes the meeting point logic

// CORRECT: Both start at head
let slow = head;
let fast = head;
```

**Mistake 3: Moving pointers before comparison**
```typescript
// WRONG: Check after moving (misses same starting position)
while (fast !== null && fast.next !== null) {
  slow = slow!.next;
  fast = fast.next.next;
  if (slow === fast) return true; // Misses if head itself is in cycle of length 1
}

// CORRECT: Your code has this right - checks after moving, which is correct for the standard algorithm
// The key is that if both start at head, moving first is correct
```

**Mistake 4: Not handling null returns from next**
```typescript
// WRONG: Assuming slow.next always exists
slow = slow.next; // Could crash if slow is null

// CORRECT: Use TypeScript non-null assertion after confirming in loop condition
// Or check explicitly: slow = slow !== null ? slow.next : null
```

**Mistake 5: Using wrong loop condition**
```typescript
// WRONG: Only checking fast
while (fast !== null) {
  // If fast.next is null, fast.next.next crashes
}

// CORRECT: Check both fast and fast.next
while (fast !== null && fast.next !== null) {
  // Safe to access fast.next.next
}
```

**Mistake 6: Confusion about what meeting means**
```typescript
// WRONG: Thinking meeting means values are equal
if (slow.val === fast.val) return true; // Nodes can have same value without cycle

// CORRECT: Check if they reference the same node object
if (slow === fast) return true;
```

## Pattern Recognition Checklist

Use these questions to identify when Floyd's Cycle Detection applies:

- Am I working with a linked list or sequence that could contain a cycle?
- Do I need to detect if a path eventually revisits a previous state?
- Is space complexity a constraint (cannot use a hash set)?
- Can I model the problem as pointers moving through a structure?
- Is there a "fast" and "slow" movement pattern that makes sense?
- Would remembering all visited states be expensive or impractical?

**When to use Hash Set instead:**
- Need to identify which specific node is revisited
- Space is not a concern
- Working with complex node identification (not just reference equality)
- Debugging or when clarity is more important than space optimization

**When to use Brent's Algorithm:**
- Need slightly better performance in practice
- Working on very large lists where 25% fewer iterations matters
- Already familiar with the more complex implementation

## Key Takeaways

**Core Pattern:** Floyd's Cycle Detection solves cycle detection in O(1) space by using two pointers moving at different speeds. If a cycle exists, they will meet.

**Key Insight:** You do not need to remember where you have been if you can detect revisiting through pointer physics. This trades memory for algorithmic cleverness.

**Tradeoffs:**
- Floyd's vs Hash Set: Space efficiency (O(1) vs O(n)) at the cost of slightly less intuitive logic
- Floyd's vs Brent's: Simplicity and industry acceptance vs marginal performance gain

**Pattern Application:** This two-pointer technique extends beyond linked lists to any problem where states can cycle - number sequences, array-based graphs, and state machines.

**Critical Implementation Details:**
- Both pointers must start at the same position
- Must check `fast !== null && fast.next !== null` to avoid null pointer errors
- Comparison is by reference equality, not value equality
- Moving slow by 1 and fast by 2 is the standard, but the ratio can vary

**Connection to Related Problems:** Cycle detection is a building block. Once you can detect cycles, you can find cycle start points (Cycle II), detect duplicates in arrays (treating as implicit linked list), and solve transformation sequence problems (Happy Number).