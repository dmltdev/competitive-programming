# Majority Element

## Problem Statement

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

Example 1:
Input: nums = [3,2,3]
Output: 3

Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2

## Constraints
- n == nums.length
- 1 <= n <= 5 * 104
- -109 <= nums[i] <= 109
- The input is generated such that a majority element will exist in the array.

## Pattern Recognition
This is an array counting problem with a guarantee: one element appears more than half the time. Three patterns apply:
- Sorting - The majority element must occupy the middle position
- Hash map frequency counting - Standard frequency tracking
- Boyer-Moore Voting - Specialized algorithm for majority element detection

The key insight is that "more than n/2 times" is a strong constraint that enables optimization beyond general frequency counting.

## Solution

### Approach 1: Sorting

Intuition: if an element occurs more than n/2 times in the array, it will always occupy the middle position when the array is sorted. Thus, we can sort the array and return the element at index n/2

Time Complexity: O(n log n) - sorting an n-sized array takes O(n log n) time.
Space Complexity: O(1) - no data structures are created, in-place sorting.

```ts
function majorityElement(nums: number[]): number {
  nums.sort((a, b) => a - b);
  const mid = Math.floor(nums.length / 2);
  return nums[mid];
}
```

### Approach 2: Hash Map

Intuition: count the occurrences of each element in the array and then return the element that occurs more than n/2 times. 

Time Complexity: O(n) - iterate through the array once to count the occurrences and then through the hash map 
Space Complexity: O(n) - store the frequencies in hash map

```ts
function majorityElement(nums: number[]): number {
  const map = new Map<number, number>();

  for (let i = 0; i < nums.length; i++) {
    const curr = map.get(nums[i]) || 0;
    map.set(nums[i], curr + 1);
  }

  const minCount = Math.floor(nums.length / 2);

  for (const [k, v] of map) {
    if (v > minCount) {
      return Number(k);
    }
  }

  return 0;
}
```

### Approach 3: Boyer-Moore Voting Algorithm

Intution: the voting algorithm is based on the fact that if there is a majority element in an array, it will always remain in the lead, even after encountering other elements.

Algorithms works this way:
- Initialize `count` to 0
- Initialize `candidate` to the first element in the array.
- Iterage through the array:
  - If count is `0`, assign the current element as the new candidate and increment `count` by 1
  - If the current element is the same as the `candidate`, increment `count` by 1
  - If the current element is different from the `candidate`, decrement `count` by 1
- Return the `candidate`

Time Complexity: O(n) - iterate an array once
Space Complexity: O(1) - no extra data structures are used

```ts
function majorityElement(nums: number[]): number {
  let candidate = nums[0];
  let count = 1;

  for (let i = 1; i < nums.length; i++) {
    if (count === 0) {
      candidate = nums[i];
      count = 1;
    } else if (nums[i] === candidate) {
      count++;
    } else {
      count--;
    }
  }

  return candidate;
}
```