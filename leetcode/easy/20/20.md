# 20. Valid Parentheses

[LeetCode](https://leetcode.com/problems/valid-parentheses/)

## Problem Statement

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

1. Open brackets are closed by the same type of brackets.
2. Open brackets are closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

**Example 1:**
```
Input: s = "()"
Output: true
```

**Example 2:**
```
Input: s = "()[]{}"
Output: true
```

**Example 3:**
```
Input: s = "(]"
Output: false
```

**Example 4:**
```
Input: s = "([])"
Output: true
```

**Constraints:**
- 1 <= s.length <= 10^4
- s consists of parentheses only '()[]{}'.

## Approach

### Pattern Recognition

This is a **stack problem** because brackets follow a Last-In-First-Out (LIFO) nesting rule:
- The most recently opened bracket must be closed first
- You cannot close an outer bracket before closing all inner brackets

Example: `"([])"`
- Open `(` => must close last
- Open `[` => must close first  
- Close `]` => matches most recent open `[` ✓
- Close `)` => matches remaining open `(` ✓

This LIFO behavior is exactly what a stack provides.

### Key Insight

When you encounter a closing bracket, you need to verify it matches the **most recent unmatched opening bracket**. A stack naturally tracks this for you:
- Push opening brackets onto the stack
- When you see a closing bracket, pop from the stack and verify they match
- If they don't match, or if the stack is empty (no opening bracket), the string is invalid

### Algorithm Steps

1. Create an empty stack to track opening brackets
2. Create a map that stores opening brackets as keys and their matching closing brackets as values
3. Iterate through each character in the string:
   - **If opening bracket** (character exists as a key in the map): Push it onto the stack
   - **If closing bracket**: 
     - Pop the top element from the stack
     - Check if stack was empty (no opening bracket to match) => invalid
     - Check if the popped opening bracket's matching closer doesn't equal current character => invalid
     - Otherwise, continue
4. After processing all characters, check if the stack is empty:
   - Empty stack => all brackets matched => valid
   - Non-empty stack => unmatched opening brackets remain => invalid

### Why the Map Design Works

The `brackets` map serves two purposes:

**Purpose 1: Identify opening brackets**
```typescript
if (brackets[char]) {
  // char is a key in the map => opening bracket
}
```
- `brackets['(']` => exists => truthy => opening bracket
- `brackets[')']` => undefined => falsy => closing bracket

**Purpose 2: Get matching closing bracket**
```typescript
const top = stack.pop();  // top is an opening bracket like '('
if (brackets[top] !== char) {
  // brackets['('] returns ')' => compare with current char
}
```

### Walkthrough Example: `"([])"`

**Initial state:**
- Stack: `[]`
- Brackets: `{ '(': ')', '{': '}', '[': ']' }`

**Step-by-step execution:**

1. `char = '('`
   - Is opening bracket? Yes (key exists in map)
   - Action: Push onto stack
   - Stack: `['(']`

2. `char = '['`
   - Is opening bracket? Yes
   - Action: Push onto stack
   - Stack: `['(', '[']`

3. `char = ']'`
   - Is opening bracket? No (not a key in map)
   - Action: Pop from stack => get `'['`
   - Check: `brackets['[']` is `']'`, matches current char ✓
   - Stack: `['(']`

4. `char = ')'`
   - Is opening bracket? No
   - Action: Pop from stack => get `'('`
   - Check: `brackets['(']` is `')'`, matches current char ✓
   - Stack: `[]`

**Final check:** Stack is empty => return `true`

### Failure Case: `"([)]"`

1. Process `'('` => Stack: `['(']`
2. Process `'['` => Stack: `['(', '[']`
3. Process `')'`:
   - Pop => get `'['`
   - Check: `brackets['[']` is `']'`, does NOT match `')'` ✗
   - Return `false` immediately

## Implementation

### TypeScript
```typescript
function isValid(s: string): boolean {
  const stack: string[] = [];

  const brackets: Record<string, string> = {
    "(": ")",
    "{": "}",
    "[": "]",
  };

  for (let i = 0; i < s.length; i++) {
    const char = s[i];

    if (brackets[char]) {
      // Opening bracket: push to stack
      stack.push(char);
    } else {
      // Closing bracket: verify match
      const top = stack.pop();

      if (top === undefined || brackets[top] !== char) {
        return false;
      }
    }
  }

  // All brackets should be matched (stack empty)
  return stack.length === 0;
}
```

### Go
```go
func isValid(s string) bool {
	stack := []rune{}

	brackets := map[rune]rune{
		'(': ')',
		'{': '}',
		'[': ']',
	}

	for _, r := range s {
		if _, ok := brackets[r]; ok {
			// Opening bracket: push to stack
			stack = append(stack, r)
		} else if len(stack) == 0 || brackets[stack[len(stack)-1]] != r {
			// Closing bracket: verify match
			return false
		} else {
			// Match found: pop from stack
			stack = stack[:len(stack)-1]
		}
	}

	// All brackets should be matched (stack empty)
	return len(stack) == 0
}
```

## Edge Cases

1. **Empty string**: `""` => Stack remains empty => `true`
2. **Only closing brackets**: `"))))"` => Stack empty on first pop => `false`
3. **Only opening brackets**: `"(((("` => Stack not empty at end => `false`
4. **Wrong bracket type**: `"(]"` => Brackets don't match when popping => `false`
5. **Wrong order**: `"([)]"` => Inner bracket closes before outer => `false`

## Complexity Analysis

**Time Complexity: O(n)**
- Single pass through the string
- Each character is processed once
- Stack push/pop operations are O(1)

**Space Complexity: O(n)**
- Worst case: all opening brackets (e.g., `"(((("`)
- Stack grows to size n
- The map uses constant space O(1) regardless of input size