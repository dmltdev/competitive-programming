# Remove Linked List Elements

## Problem Statement

Given the head of a linked list and a value `val`, remove all nodes with `node.val == val` and return the new head.

**Input:** Head of a singly linked list, target value
**Output:** Head of modified list with all target nodes removed
**Constraints:** Node values and target are integers

---

## Pattern Recognition

**Problem Type:** Linked List Traversal with In-Place Modification

**Key Pattern:** Two-phase pointer manipulation
1. Handle head edge case (leading nodes to remove)
2. Standard traversal with conditional deletion

Why this pattern:
- Linked lists don't support random access, so we must traverse sequentially
- Deletion requires access to the previous node to update pointers
- Head is a special case because it has no previous node

---

## Approach Comparison

### Iterative Approach

**Intuition:**
We can't delete a node unless we have access to the node before it. The head is special because nothing points to it. We solve this in two phases:

1. **Phase 1 - Adjust Head:** Move head forward until it doesn't match val (or becomes null)
2. **Phase 2 - Clean Remaining List:** Traverse with curr, check curr.next, delete when needed

**Why Two Phases:**
- We can't use the same deletion logic for head because we don't have a "previous" node
- After head is set correctly, the rest follows standard linked list deletion

**Implementation:**

```typescript
function removeElements(head: ListNode | null, val: number): ListNode | null {
  // Edge case: empty list
  if (!head) return null;

  // Phase 1: Move head past all nodes that match val
  // Keep shifting head forward until we find a keeper or reach null
  while (head && head.val === val) {
    head = head.next;
  }

  // At this point, head either:
  // - Points to first node that doesn't match val
  // - Is null (entire list was target values)

  let curr: ListNode = head;

  // Phase 2: Clean the rest of the list
  // We look ahead with curr.next to maintain access to previous node
  while (curr && curr.next) {
    if (curr.next.val === val) {
      // Delete: skip over curr.next by pointing to next.next
      curr.next = curr.next.next;
      // Don't advance curr - check the new curr.next
    } else {
      // Keep: advance to next node
      curr = curr.next;
    }
  }

  return head;
}
```

**Complexity:**
- **Time:** O(n) - single pass through list
- **Space:** O(1) - only pointer variables, no recursion stack

**Trace Example:**
```
Input: 1 -> 2 -> 6 -> 3 -> 6 -> null, val = 6

Phase 1 (adjust head):
  head.val = 1 ≠ 6, stop
  head stays at 1

Phase 2 (clean rest):
  curr = 1, curr.next = 2 (≠ 6), advance
  curr = 2, curr.next = 6 (= 6), delete -> 2.next = 3
  curr = 2, curr.next = 3 (≠ 6), advance
  curr = 3, curr.next = 6 (= 6), delete -> 3.next = null
  curr = 3, curr.next = null, stop

Output: 1 -> 2 -> 3 -> null
```

---

### Recursive Approach

**Intuition:**
Trust that the recursive call handles "everything after this node." Our job at each level is simple:
1. If current node is null, return null (base case)
2. If current node matches val, skip it and return result of recursive call
3. If current node is safe, attach cleaned tail and return current node

Why recursion works:
- Each recursive call processes one node's decision: keep or skip
- The "rest of the list" is already cleaned by recursive calls
- Naturally handles head edge case because we check head.val before deciding what to return

**Implementation:**

```typescript
function removeElements_recursive(head: ListNode | null, val: number): ListNode | null {
  // Base case: reached end of list
  if (head === null) return null;

  // Decision point: should we keep this node?
  if (head.val === val) {
    // Skip current node, return cleaned tail
    return removeElements_recursive(head.next, val);
  }

  // Keep current node, attach cleaned tail
  head.next = removeElements_recursive(head.next, val);
  return head;
}
```

**Complexity:**
- **Time:** O(n) - visits each node once
- **Space:** O(n) - recursion stack depth equals list length

**Trace Example (Call Stack):**
```
Input: 1 -> 6 -> 2 -> null, val = 6

Call 1: removeElements(1 -> 6 -> 2 -> null, 6)
  head.val = 1 ≠ 6, keep node
  Recurse with head.next...

  Call 2: removeElements(6 -> 2 -> null, 6)
    head.val = 6 = 6, skip node
    Return result of recursive call...

    Call 3: removeElements(2 -> null, 6)
      head.val = 2 ≠ 6, keep node
      Recurse with head.next...

      Call 4: removeElements(null, 6)
        head = null, return null
      
      Call 3 returns: 2 -> null
    
    Call 2 returns: 2 -> null (skipped 6)
  
  Call 1: 1.next = 2 -> null
  Call 1 returns: 1 -> 2 -> null

Output: 1 -> 2 -> null
```

---

## Iterative vs Recursive Tradeoffs

| Aspect | Iterative | Recursive |
|--------|-----------|-----------|
| **Readability** | Two-phase logic requires more mental tracking | Single decision per node, more declarative |
| **Space** | O(1) - no stack usage | O(n) - recursion stack grows with list length |
| **Performance** | Faster in practice - no function call overhead | Slower - each recursive call has overhead |
| **Head Handling** | Requires explicit while loop before main traversal | Natural - just another node to process |
| **Stack Overflow Risk** | None | Possible for very long lists (>10k nodes) |

**When to Choose Iterative:**
- Production code (space efficiency, no stack overflow risk)
- Performance-critical paths
- Very long lists

**When to Choose Recursive:**
- Interview settings (demonstrates recursion understanding)
- Prototyping (faster to write correctly)
- Lists guaranteed to be short

---

## Edge Cases

Both approaches handle:

1. **Empty list:** `null` input returns `null`
2. **All nodes match:** `6 -> 6 -> 6`, val=6 returns `null`
3. **No nodes match:** `1 -> 2 -> 3`, val=6 returns `1 -> 2 -> 3`
4. **Head matches:** `6 -> 1 -> 2`, val=6 returns `1 -> 2`
5. **Tail matches:** `1 -> 2 -> 6`, val=6 returns `1 -> 2`
6. **Consecutive matches:** `1 -> 6 -> 6 -> 2`, val=6 returns `1 -> 2`

---

## Common Mistakes

**Iterative Version:**
- Forgetting to advance `curr` when not deleting → infinite loop
- Advancing `curr` when deleting → skips checking the new `curr.next`
- Not handling head separately → can't delete head nodes

**Recursive Version:**
- Forgetting to update `head.next` before returning → tail not attached
- Only returning `head` without recursing → tail not cleaned
- Not handling base case → stack overflow on null access

---

## Pattern Generalization

**This is the standard "in-place linked list deletion" pattern:**

```
Iterative Template:
1. Handle head edge case (loop while head matches condition)
2. Set curr = head
3. While curr and curr.next exist:
   - If curr.next matches condition: curr.next = curr.next.next
   - Else: curr = curr.next

Recursive Template:
1. If head is null: return null
2. If head matches condition: return recurse(head.next)
3. Else: head.next = recurse(head.next); return head
```

**Related Problems:**
- Delete duplicates from sorted list
- Remove nth node from end
- Delete node in a linked list (when given direct node access)

**Recognition Signal:**
"Remove/delete nodes based on some condition" → Use this pattern, adjust the condition check.
