# LeetCode 225: Implement Stack using Queues

## Problem Description

Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack.

**Interface:**
- `void push(int x)` - Pushes element x to the top of the stack
- `int pop()` - Removes the element on the top of the stack and returns it
- `int top()` - Returns the element on the top of the stack
- `boolean empty()` - Returns true if the stack is empty, false otherwise

**Constraints:**
- You must use only standard queue operations: push to back, peek/pop from front, size, and is empty
- 1 <= x <= 9
- At most 100 calls will be made to push, pop, top, and empty
- All calls to pop and top are valid

**Example:**
```
Input: ["MyStack", "push", "push", "top", "pop", "empty"]
       [[], [1], [2], [], [], []]
Output: [null, null, null, 2, 2, false]

Explanation:
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top();    // return 2
myStack.pop();    // return 2
myStack.empty();  // return false
```

## Pattern Recognition

### Problem Category
**Data Structure Design - Interface Adaptation**

This problem requires implementing one abstract data type (stack - LIFO) using another with different access patterns (queue - FIFO).

### Algorithmic Pattern
**Queue Rotation / Queue Simulation**

The core challenge is reconciling LIFO (Last-In-First-Out) behavior with FIFO (First-In-First-Out) mechanisms. Since queues only allow front access, you must reorder elements after operations to maintain the correct retrieval order for stack semantics.

### Key Insight

A queue naturally maintains insertion order (FIFO), but a stack requires reverse order (LIFO). The newest element must be accessible first. Since queues only allow access at the front, you must physically move the newest element to the front position after every insertion.

### Related Problems

1. **LeetCode 232: Implement Queue using Stacks** - The inverse problem. Uses two stacks to simulate queue's FIFO behavior. Same tradeoff decision: make enqueue or dequeue expensive.

2. **LeetCode 155: Min Stack** - Implements stack with additional getMin() operation. Similar design constraint: maintain stack interface while tracking extra information.

3. **LeetCode 622: Design Circular Queue** - Implement bounded queue with fixed capacity. Shows queue implementation fundamentals useful for understanding this problem.

4. **LeetCode 641: Design Circular Deque** - Implement double-ended queue. Demonstrates how access pattern constraints affect implementation choices.

5. **LeetCode 146: LRU Cache** - Combines data structures (hash map + doubly linked list) to meet specific access requirements. Similar concept of adapting data structures for required operations.

## Solution Approaches

### Approach 1: Two Queues with Expensive Push

Use two queues. On push, transfer all elements from main queue to temporary queue, add new element to main queue, transfer everything back.

**Time Complexity:**
- push: O(n)
- pop: O(1)
- top: O(1)
- empty: O(1)

**Space Complexity:** O(n) for two queues

**When to use:** Traditional textbook approach, easier to understand conceptually.

### Approach 2: Two Queues with Expensive Pop

Keep elements in insertion order. On pop, transfer all but the last element to the temporary queue, remove the last element, swap queue references.

**Time Complexity:**
- push: O(1)
- pop: O(n)
- top: O(n)
- empty: O(1)

**Space Complexity:** O(n)

**When to use:** When push operations vastly outnumber pop/top operations.

### Approach 3: One Queue with Expensive Push ⭐ (Optimal)

Use a single queue. After pushing a new element to the back, rotate the queue by removing from front and adding to back until the new element reaches the front.

**Time Complexity:**
- push: O(n)
- pop: O(1)
- top: O(1)
- empty: O(1)

**Space Complexity:** O(n)

**Why this is optimal:** Minimizes space overhead (one queue instead of two) while maintaining the same time complexity. Makes the most frequent read operations (pop/top) very fast.

### Approach 4: One Queue with Expensive Pop

Keep elements in insertion order. On pop, rotate n-1 times to move all elements except the last, then remove it.

**Time Complexity:**
- push: O(1)
- pop: O(n)
- top: O(n)
- empty: O(1)

**Space Complexity:** O(n)

**When to use:** If push operations are far more frequent than pop/top operations.

## Optimal Solution Explained

### Algorithm Properties

**Invariant:** After each push operation, the queue maintains elements in reverse insertion order, with the most recently added element at index 0.

**Queue rotation property:** Rotating a queue (remove from front, add to back) eventually cycles all elements back to their original relative positions, but shifts their absolute positions.

**State tracking:** The queue's front always represents the stack's top. No additional state variables needed.

### Step-by-Step Example

```
Initial state: queue = []

Operation: push(1)
- queue.push(1) → [1]
- Rotations needed: 1 - 1 = 0
- Final: [1] (1 is at front)

Operation: push(2)
- queue.push(2) → [1, 2]
- Rotations needed: 2 - 1 = 1
  - Rotation 1: shift()=1, push(1) → [2, 1]
- Final: [2, 1] (2 is at front)

Operation: push(3)
- queue.push(3) → [2, 1, 3]
- Rotations needed: 3 - 1 = 2
  - Rotation 1: shift()=2, push(2) → [1, 3, 2]
  - Rotation 2: shift()=1, push(1) → [3, 2, 1]
- Final: [3, 2, 1] (3 is at front)

Operation: top()
- Return queue[0] = 3

Operation: pop()
- shift() → 3
- queue = [2, 1] (2 now at front)

Operation: pop()
- shift() → 2
- queue = [1]

Operation: empty()
- queue.length === 0? No
- Return false
```

## Implementation

### TypeScript

```typescript
class MyStack {
  queue: number[];

  constructor() {
    this.queue = [];
  }

  // O(n) - rotate queue to bring new element to front
  push(item: number): void {
    this.queue.push(item);
    // Rotate all elements except the newly added one
    for (let i = 0; i < this.queue.length - 1; i++) {
      this.queue.push(this.queue.shift()!);
    }
  }

  // O(1) - front element is always the stack top
  pop(): number | undefined {
    return this.queue.shift();
  }

  // O(1) - peek at front element
  top(): number | undefined {
    return this.queue[0];
  }

  // O(1) - check if queue is empty
  empty(): boolean {
    return this.queue.length === 0;
  }
}
```

### Go

```go
package main

type MyStack struct {
    queue []int
}

func Constructor() MyStack {
    return MyStack{
        queue: []int{},
    }
}

// O(n) - rotate queue to bring new element to front
func (this *MyStack) Push(x int) {
    this.queue = append(this.queue, x)
    // Rotate all elements except the newly added one
    for i := 0; i < len(this.queue)-1; i++ {
        this.queue = append(this.queue, this.queue[0])
        this.queue = this.queue[1:]
    }
}

// O(1) - front element is always the stack top
func (this *MyStack) Pop() int {
    val := this.queue[0]
    this.queue = this.queue[1:]
    return val
}

// O(1) - peek at front element
func (this *MyStack) Top() int {
    return this.queue[0]
}

// O(1) - check if queue is empty
func (this *MyStack) Empty() bool {
    return len(this.queue) == 0
}
```

### Kotlin

```kotlin
class MyStack() {
    private val queue = ArrayDeque<Int>()

    // O(n) - rotate queue to bring new element to front
    fun push(x: Int) {
        queue.addLast(x)
        // Rotate all elements except the newly added one
        repeat(queue.size - 1) {
            queue.addLast(queue.removeFirst())
        }
    }

    // O(1) - front element is always the stack top
    fun pop(): Int {
        return queue.removeFirst()
    }

    // O(1) - peek at front element
    fun top(): Int {
        return queue.first()
    }

    // O(1) - check if queue is empty
    fun empty(): Boolean {
        return queue.isEmpty()
    }
}
```

### Rust

```rust
use std::collections::VecDeque;

struct MyStack {
    queue: VecDeque<i32>,
}

impl MyStack {
    fn new() -> Self {
        MyStack {
            queue: VecDeque::new(),
        }
    }
    
    // O(n) - rotate queue to bring new element to front
    fn push(&mut self, x: i32) {
        self.queue.push_back(x);
        // Rotate all elements except the newly added one
        for _ in 0..self.queue.len() - 1 {
            let front = self.queue.pop_front().unwrap();
            self.queue.push_back(front);
        }
    }
    
    // O(1) - front element is always the stack top
    fn pop(&mut self) -> i32 {
        self.queue.pop_front().unwrap()
    }
    
    // O(1) - peek at front element
    fn top(&self) -> i32 {
        *self.queue.front().unwrap()
    }
    
    // O(1) - check if queue is empty
    fn empty(&self) -> bool {
        self.queue.is_empty()
    }
}
```

## Edge Cases and Testing

### Test Cases

```
Single element: push(1), pop() → 1 (queue becomes empty)
Multiple push then pop: push(1), push(2), push(3), pop() → 3 (LIFO order maintained)
Interleaved operations: push(1), push(2), pop(), push(3), pop() → 2, then 3
Empty check after pops: push(1), pop(), empty() → true
Peek vs pop: push(5), top() → 5, top() → 5 (doesn't remove), pop() → 5
Maximum operations: 100 pushes followed by 100 pops (stress test)
```

### Common Mistakes

**1. Using array index access beyond queue operations**
```typescript
// WRONG: Direct index manipulation
push(item: number): void {
  this.queue.unshift(item); // unshift is NOT a queue operation
}
```
Correct: Only use push (enqueue to back) and shift (dequeue from front).

**2. Incorrect rotation count**
```typescript
// WRONG: Rotating too many or too few times
for (let i = 0; i < this.queue.length; i++) { // Rotates n times instead of n-1
  this.queue.push(this.queue.shift()!);
}
```
Correct: Rotate exactly `length - 1` times. Rotating n times returns to original state.

**3. Forgetting to handle empty queue in pop/top**
```typescript
// WRONG: Doesn't handle undefined
pop(): number {
  return this.queue.shift(); // TypeScript error: might be undefined
}
```
Correct: Return `number | undefined` or throw error for invalid operations.

**4. Not maintaining the invariant during edge cases**
```typescript
// WRONG: Special-casing single element
push(item: number): void {
  this.queue.push(item);
  if (this.queue.length > 1) { // Unnecessary check
    for (let i = 0; i < this.queue.length - 1; i++) {
      this.queue.push(this.queue.shift()!);
    }
  }
}
```
Correct: The rotation logic naturally handles all cases. When length is 1, the loop doesn't run (0 iterations), which is correct.

## Pattern Recognition Checklist

Use this checklist to recognize when to apply queue rotation or data structure adaptation:

- [ ] Is the problem asking you to implement one data structure using another with different access patterns?
- [ ] Does the source data structure have limited access points (like queue's front-only access)?
- [ ] Can you transform the data structure's order after each operation to maintain required semantics?
- [ ] Is there a tradeoff between making insertion or removal expensive?
- [ ] Would rotating or transferring elements maintain the required invariant?
- [ ] Is the operation frequency known (to choose which operation to make expensive)?

If you answer yes to most of these, consider queue rotation or the two-queue pattern.

## Key Takeaways

1. **Core pattern:** Data structure adaptation requires reconciling different access patterns through element reordering.

2. **Key insight:** Since stacks need LIFO and queues provide FIFO, you must physically reorder elements after operations. The choice is whether to reorder during push or pop.

3. **Design tradeoff:** Making push expensive (O(n)) allows pop and top to be O(1), which is usually preferred since read operations are often more frequent than writes in typical stack usage patterns.

4. **Space optimization:** One-queue rotation is cleaner than two-queue shuffling with identical time complexity.

5. **Implementation principle:** Maintain a simple invariant (newest element at front) rather than complex state tracking.

6. **Related pattern:** This is the inverse of implementing queue using stacks (LeetCode 232), where you face the same decision about which operation to make expensive.

7. **Production consideration:** In real systems, if operation frequencies are known, optimize the common case. If pushes vastly outnumber pops, the expensive-pop approach might be better despite worse worst-case complexity.

## Complexity Summary

| Operation | Time Complexity | Space Complexity |
|-----------|----------------|------------------|
| push      | O(n)           | O(1) auxiliary   |
| pop       | O(1)           | O(1) auxiliary   |
| top       | O(1)           | O(1) auxiliary   |
| empty     | O(1)           | O(1) auxiliary   |
| Overall   | -              | O(n) total       |

## Language-Specific Notes

| Language | Queue Type | Key Methods |
|----------|-----------|-------------|
| TypeScript | `number[]` | `push()`, `shift()`, `[0]` |
| Go | `[]int` | `append()`, slice `[1:]`, `[0]` |
| Kotlin | `ArrayDeque<Int>` | `addLast()`, `removeFirst()`, `first()` |
| Rust | `VecDeque<i32>` | `push_back()`, `pop_front()`, `front()` |