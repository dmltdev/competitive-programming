# 242. Valid Anagram

## Problem Description

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Constraints:**
- `1 <= s.length, t.length <= 5 * 10^4`
- `s` and `t` consist of lowercase English letters

## Examples
```
Input: s = "anagram", t = "nagaram"
Output: true

Input: s = "rat", t = "car"
Output: false
```

## Approach

### Pattern: Character Frequency Counting

This is a **hash table / array counting** problem. The core insight is that two strings are anagrams if and only if they contain the same characters with the same frequencies.

### Strategy

1. **Early exit**: If lengths differ, strings cannot be anagrams
2. **Use fixed-size array**: Since we only have 26 lowercase letters, use an array instead of a hash map
3. **Single-pass counting**: Increment counts for `s`, decrement for `t` in the same loop
4. **Verify**: All counts should be zero if strings are anagrams

### Why This Works

- Each character in `s` adds 1 to its count
- Each character in `t` subtracts 1 from its count
- If both strings have identical character frequencies, all counts cancel out to 0
- If any count is non-zero, the frequencies don't match

### Optimization Over Naive Approach

**Naive approach:**
```typescript
// Count s, count t, then compare → O(n) time, O(1) space, but 3 passes
```

**Our approach:**
```typescript
// Count both simultaneously → O(n) time, O(1) space, 1 pass through strings
```

## Implementation
```typescript
function isAnagram(s: string, t: string): boolean {
    // Different lengths → cannot be anagrams
    if (s.length !== t.length) return false;
    
    // Array for 26 lowercase letters (a-z)
    // Index 0 = 'a', index 1 = 'b', ..., index 25 = 'z'
    const counts: number[] = new Array(26).fill(0);
    
    // Single pass: increment for s, decrement for t
    for (let i = 0; i < s.length; i++) {
        counts[s.charCodeAt(i) - 97]++;  // 'a' has charCode 97
        counts[t.charCodeAt(i) - 97]--;
    }
    
    // If all counts are 0, character frequencies match
    for (const c of counts) {
        if (c !== 0) return false;
    }
    
    return true;
}
```

## Complexity Analysis

- **Time Complexity:** O(n)
  - First loop: O(n) where n = length of strings
  - Second loop: O(26) = O(1) constant
  - Total: O(n)

- **Space Complexity:** O(1)
  - Fixed 26-element array regardless of input size
  - No additional space that grows with input

## Trace Example

**Input:** `s = "anagram"`, `t = "nagaram"`

**Initial state:**
```
counts = [0, 0, 0, ..., 0]  // 26 zeros
```

**After processing each index:**

| i | s[i] | t[i] | counts[s[i]]++ | counts[t[i]]-- | Result |
|---|------|------|----------------|----------------|---------|
| 0 | 'a' | 'n' | counts[0] = 1 | counts[13] = -1 | `[1,0,...,-1,...,0]` |
| 1 | 'n' | 'a' | counts[13] = 0 | counts[0] = 0 | `[0,0,...,0,...,0]` |
| 2 | 'a' | 'g' | counts[0] = 1 | counts[6] = -1 | `[1,0,...,-1,...,0]` |
| 3 | 'g' | 'a' | counts[6] = 0 | counts[0] = 0 | `[0,0,...,0,...,0]` |
| 4 | 'r' | 'r' | counts[17] = 1 | counts[17] = 0 | `[0,0,...,0,...,0]` |
| 5 | 'a' | 'a' | counts[0] = 1 | counts[0] = 0 | `[0,0,...,0,...,0]` |
| 6 | 'm' | 'm' | counts[12] = 1 | counts[12] = 0 | `[0,0,...,0,...,0]` |

**Final state:** All counts = 0 → **true**

## Edge Cases
```typescript
// Empty strings
s = "", t = "" → true ✓

// Single character match
s = "a", t = "a" → true ✓

// Single character mismatch
s = "a", t = "b" → false ✓

// Different lengths
s = "ab", t = "abc" → false ✓ (caught by length check)

// Same characters, different frequencies
s = "aab", t = "abb" → false ✓
```

## Alternative Solutions

### Solution 2: Hash Map (for Unicode support)
```typescript
function isAnagram(s: string, t: string): boolean {
    if (s.length !== t.length) return false;
    
    const counts = new Map<string, number>();
    
    for (let i = 0; i < s.length; i++) {
        counts.set(s[i], (counts.get(s[i]) || 0) + 1);
        counts.set(t[i], (counts.get(t[i]) || 0) - 1);
    }
    
    for (const count of counts.values()) {
        if (count !== 0) return false;
    }
    
    return true;
}
```

**Time:** O(n) | **Space:** O(k) where k = number of unique characters

**When to use:** If the problem allows Unicode or special characters

### Solution 3: Sorting
```typescript
function isAnagram(s: string, t: string): boolean {
    if (s.length !== t.length) return false;
    
    const sortedS = s.split('').sort().join('');
    const sortedT = t.split('').sort().join('');
    
    return sortedS === sortedT;
}
```

**Time:** O(n log n) | **Space:** O(n)

**When to use:** Quick implementation, not performance-critical

## Key Takeaways

1. **Fixed alphabet → Use array instead of hash map** for O(1) space
2. **Increment/decrement pattern** allows single-pass counting
3. **Character to index mapping:** `charCodeAt(i) - 97` converts 'a'-'z' to 0-25
4. **Early exit optimization** saves time when lengths differ
5. This pattern applies to any "character frequency comparison" problem