# LeetCode 682: Baseball Game

## Problem Description

You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.

You are given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record and is one of the following:

- An integer `x` - Record a new score of `x`
- `'+'` - Record a new score that is the sum of the previous two scores
- `'D'` - Record a new score that is the double of the previous score
- `'C'` - Invalidate the previous score, removing it from the record

Return the sum of all the scores on the record after applying all the operations.

The test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.

**Difficulty**: Easy  
**Topics**: Array, Stack, Simulation

### Examples

**Example 1:**

```
Input: ops = ["5","2","C","D","+"]
Output: 30
Explanation:
"5" - Add 5 to the record, record is now [5].
"2" - Add 2 to the record, record is now [5, 2].
"C" - Invalidate and remove the previous score, record is now [5].
"D" - Add 2 * 5 = 10 to the record, record is now [5, 10].
"+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].
The total sum is 5 + 10 + 15 = 30.
```

**Example 2:**

```
Input: ops = ["5","-2","4","C","D","9","+","+"]
Output: 27
Explanation:
"5" - Add 5 to the record, record is now [5].
"-2" - Add -2 to the record, record is now [5, -2].
"4" - Add 4 to the record, record is now [5, -2, 4].
"C" - Invalidate and remove the previous score, record is now [5, -2].
"D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].
"9" - Add 9 to the record, record is now [5, -2, -4, 9].
"+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].
"+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].
The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.
```

**Example 3:**

```
Input: ops = ["1","C"]
Output: 0
Explanation:
"1" - Add 1 to the record, record is now [1].
"C" - Invalidate and remove the previous score, record is now [].
Since the record is empty, the total sum is 0.
```

### Constraints

- `1 <= operations.length <= 1000`
- `operations[i]` is `"C"`, `"D"`, `"+"`, or a string representing an integer in the range `[-3 * 10^4, 3 * 10^4]`
- For operation `"+"`, there will always be at least two previous scores on the record
- For operations `"C"` and `"D"`, there will always be at least one previous score on the record

---

## Pattern Recognition

### Problem Category: Stack-based Simulation

This problem has these structural properties:

- We only care about recent elements (top of stack)
- Operations modify or reference the most recent 1-2 elements
- We never need random access to middle elements
- We add/remove from one end only (LIFO - Last In, First Out)

### Key Insight

**Stack operations map perfectly to the problem requirements:**

- "D" needs the last element → stack top
- "+" needs last two elements → top and second-to-top
- "C" removes the last element → pop from stack
- Integer adds new element → push to stack

The stack naturally maintains insertion order and provides O(1) access to recent elements.

### When to Use This Pattern

Use a stack when you can answer yes to most of these:

- Does the problem only require access to the most recent 1-3 elements?
- Do operations add/remove from one end of a sequence?
- Is there a LIFO (Last In, First Out) access pattern?
- Do newer elements invalidate, modify, or depend on the most recent older elements?
- Is there no need for random access to middle elements?
- Are we processing elements sequentially and maintaining state about recent items?

### Related Problems

This same stack simulation pattern appears in:

1. **Valid Parentheses** - Use stack to match opening/closing brackets, only care about most recent unmatched bracket
2. **Evaluate Reverse Polish Notation** - Process operators that apply to the most recent operands, classic stack evaluation
3. **Min Stack** - Maintain minimum value while supporting stack operations
4. **Asteroid Collision** - Process elements where new elements only interact with recent ones
5. **Daily Temperatures** - Find next warmer temperature using monotonic stack

---

## Solution Approach

### Algorithm

1. Initialize empty stack to store valid scores
2. For each operation:
   - If numeric string: Convert to integer and push onto stack
   - If "D": Push (last element × 2) onto stack
   - If "+": Push (last element + second-to-last element) onto stack
   - If "C": Pop from stack (remove last element)
3. Sum all remaining elements in stack

### Why Stack Works

**Stack Properties We Exploit:**

- LIFO structure matches our access pattern
- Constant-time operations: push, pop, access top are all O(1)
- Automatic ordering: we never need to reorder elements
- Size tracking: array length tells us element count

**State Tracking:**

- Stack top: `stack[stack.length - 1]`
- Second from top: `stack[stack.length - 2]`
- No additional variables needed

### Step-by-Step Example

```
Input: ops = ["5", "2", "C", "D", "+"]

Initial: stack = []

Operation "5":
  Parse integer: 5
  Action: Push 5
  Stack: [5]

Operation "2":
  Parse integer: 2
  Action: Push 2
  Stack: [5, 2]

Operation "C":
  Action: Pop (remove last element)
  Stack: [5]

Operation "D":
  Last element: stack[0] = 5
  Action: Push 5 * 2 = 10
  Stack: [5, 10]

Operation "+":
  Last element: stack[1] = 10
  Second-to-last: stack[0] = 5
  Action: Push 10 + 5 = 15
  Stack: [5, 10, 15]

Final sum: 5 + 10 + 15 = 30
```

### Complexity Analysis

**Time Complexity: O(n)**

- We process each of n operations exactly once
- Each operation (push, pop, access) is O(1)
- Final summation is O(k) where k ≤ n (number of remaining scores)
- Total: O(n + k) = O(n)

**Space Complexity: O(n)**

- Worst case: all operations add numbers, no "C" operations
- Stack contains at most n elements
- Best case: O(1) if all scores are cancelled

---

## Implementation

### TypeScript

```typescript
function calPoints(operations: string[]): number {
  const stack: number[] = [];

  for (const op of operations) {
    if (op === "C") {
      stack.pop();
    } else if (op === "D") {
      const lastScore = stack[stack.length - 1];
      stack.push(lastScore * 2);
    } else if (op === "+") {
      const lastScore = stack[stack.length - 1];
      const secondLastScore = stack[stack.length - 2];
      stack.push(lastScore + secondLastScore);
    } else {
      stack.push(parseInt(op));
    }
  }

  return stack.reduce((sum, score) => sum + score, 0);
}
```

**Alternative with switch statement:**

```typescript
function calPoints(operations: string[]): number {
  const stack: number[] = [];

  for (const op of operations) {
    switch (op) {
      case "C":
        stack.pop();
        break;
      case "D":
        stack.push(stack[stack.length - 1] * 2);
        break;
      case "+":
        stack.push(stack[stack.length - 1] + stack[stack.length - 2]);
        break;
      default:
        stack.push(Number(op));
    }
  }

  return stack.reduce((sum, score) => sum + score, 0);
}
```

### Go

```go
func calPoints(operations []string) int {
    stack := []int{}

    for _, op := range operations {
        switch op {
        case "C":
            stack = stack[:len(stack)-1]
        case "D":
            lastScore := stack[len(stack)-1]
            stack = append(stack, lastScore*2)
        case "+":
            lastScore := stack[len(stack)-1]
            secondLastScore := stack[len(stack)-2]
            stack = append(stack, lastScore+secondLastScore)
        default:
            num, _ := strconv.Atoi(op)
            stack = append(stack, num)
        }
    }

    sum := 0
    for _, score := range stack {
        sum += score
    }
    return sum
}
```

### Kotlin

```kotlin
fun calPoints(operations: Array<String>): Int {
    val stack = mutableListOf<Int>()

    for (op in operations) {
        when (op) {
            "C" -> stack.removeLast()
            "D" -> stack.add(stack.last() * 2)
            "+" -> stack.add(stack.last() + stack[stack.size - 2])
            else -> stack.add(op.toInt())
        }
    }

    return stack.sum()
}
```

### Rust

```rust
impl Solution {
    pub fn cal_points(operations: Vec<String>) -> i32 {
        let mut stack: Vec<i32> = Vec::new();

        for op in operations.iter() {
            match op.as_str() {
                "C" => { stack.pop(); }
                "D" => {
                    let last = *stack.last().unwrap();
                    stack.push(last * 2);
                }
                "+" => {
                    let len = stack.len();
                    stack.push(stack[len - 1] + stack[len - 2]);
                }
                _ => { stack.push(op.parse().unwrap()); }
            }
        }

        stack.iter().sum()
    }
}
```

### Language-Specific Notes

| Feature      | Go                     | Kotlin               | Rust                     | TypeScript              |
| ------------ | ---------------------- | -------------------- | ------------------------ | ----------------------- |
| Stack Type   | `[]int`                | `MutableList<Int>`   | `Vec<i32>`               | `number[]`              |
| Push         | `append(stack, val)`   | `stack.add(val)`     | `stack.push(val)`        | `stack.push(val)`       |
| Pop          | `stack[:len(stack)-1]` | `stack.removeLast()` | `stack.pop()`            | `stack.pop()`           |
| Last Element | `stack[len(stack)-1]`  | `stack.last()`       | `*stack.last().unwrap()` | `stack[stack.length-1]` |
| Parse String | `strconv.Atoi(s)`      | `s.toInt()`          | `s.parse::<i32>()`       | `parseInt(s)`           |
| Sum          | Manual loop            | `stack.sum()`        | `stack.iter().sum()`     | `reduce()`              |

---

## Edge Cases and Testing

### Edge Cases

```
Single operation that adds:
  Input: ["5"]
  Output: 5
  Reason: One score in record

Single operation cancelled:
  Input: ["1", "C"]
  Output: 0
  Reason: Record becomes empty

All operations cancelled:
  Input: ["1", "2", "3", "C", "C", "C"]
  Output: 0
  Reason: All scores removed

Negative numbers:
  Input: ["-5", "D"]
  Output: -15
  Reason: -5 + (-10) = -15

Zero values:
  Input: ["0", "D", "+"]
  Output: 0
  Reason: [0, 0, 0] sums to 0

Chain of + operations:
  Input: ["1", "2", "+", "+"]
  Output: 11
  Reason: [1, 2, 3, 5] → 1+2+3+5 = 11

Large positive/negative values:
  Input: ["30000", "-30000", "+"]
  Output: 0
  Reason: [30000, -30000, 0] sums to 0
```

### Common Mistakes

1. **Wrong indices for stack access**

   ```typescript
   // WRONG - accessing second-to-last instead of last for "D"
   stack[stack.length - 2];

   // CORRECT
   stack[stack.length - 1];
   ```

2. **Wrong indices for "+" operation**

   ```typescript
   // WRONG - off by one
   stack[stack.length - 2] + stack[stack.length - 3];

   // CORRECT - last + second-to-last
   stack[stack.length - 1] + stack[stack.length - 2];
   ```

3. **Not handling negative numbers properly**

   ```typescript
   // WRONG - only checks first char
   if (op[0] >= "0" && op[0] <= "9")
     // CORRECT - parseInt handles "-5" correctly
     parseInt(op);
   ```

4. **Modifying values in place instead of pushing**

   ```typescript
   // WRONG - modifies existing score
   stack[stack.length - 1] *= 2;

   // CORRECT - adds new score
   stack.push(stack[stack.length - 1] * 2);
   ```

5. **Forgetting to actually pop for "C"**

   ```typescript
   // WRONG - reads but doesn't remove
   const removed = stack[stack.length - 1];

   // CORRECT
   stack.pop();
   ```

6. **Unnecessary defensive checks**

   ```typescript
   // WRONG - problem guarantees validity
   if (stack.length >= 2) {
     stack.push(stack[stack.length - 1] + stack[stack.length - 2]);
   }

   // CORRECT - trust constraints
   stack.push(stack[stack.length - 1] + stack[stack.length - 2]);
   ```

---

## Key Takeaways

1. **Stack is the natural choice when only recent elements matter**

   - Operations reference only the last 1-2 elements
   - No random access needed
   - LIFO pattern matches problem requirements

2. **Array indexing in different languages**

   - Last element: `arr[length - 1]`
   - Second-to-last: `arr[length - 2]`
   - Go uses slicing for pop: `arr[:len(arr)-1]`

3. **Trust problem constraints**

   - Problem guarantees operations are valid
   - No need for defensive length checks
   - Simplifies implementation

4. **Pattern recognition**

   - Problems asking for operations on recent history → stack
   - Sequential processing with local dependencies → stack
   - Nested structures or matching pairs → stack

5. **All stack operations are O(1)**

   - Makes simulation problems efficient
   - Linear time overall for n operations

6. **This pattern appears frequently**
   - Expression evaluation (RPN, infix to postfix)
   - Bracket/parentheses matching
   - Backtracking and undo operations
   - Monotonic stack problems
   - Call stack simulation
