# Capacity to ship packages within D days

## Problem Statement

Given an array of package weights and a number of days, find the minimum ship capacity needed to transport all packages in order within the given time constraint. Each day we load packages sequentially until adding the next package would exceed capacity, then we start a new day.

**Key constraints:**
- Packages must be shipped in the given order (no reordering)
- Each package must fit in the ship (capacity >= max weight)
- All packages must be shipped within `days` days

**Input:** `weights = [1,2,3,4,5,6,7,8,9,10]`, `days = 5`  
**Output:** `15`

## Pattern Recognition

Problem Category - Binary Search

Why this pattern fits:

This is not a traditional "search for a value in a sorted array" problem. We are searching for the min capacity that satisfies a condition. 

- The answer has a valid range: between `max(weights)` (minimum possible) and `sum(weights)` (maximum needed)
-  The answer space has monotonic properties: if a capacity `C` works, then any capacity `C+1, C+2, ...` also works
- We can verify if a capacity works in O(n) time: simulate the shipping process

When you see "find the minimum/maximum value that satisfies a condition" and the answer space has monotonic properties, think binary search on the answer space.

**Related problems using this pattern:**
- Koko Eating Bananas
- Minimum Time to Complete Trips
- Split Array Largest Sum
- Magnetic Force Between Two Balls

## Brute Force Approach

**Strategy:** Try every possible capacity from `max(weights)` to `sum(weights)` and return the first one that works.
```python
def shipWithinDays(weights, days):
    for capacity in range(max(weights), sum(weights) + 1):
        if can_ship(weights, days, capacity):
            return capacity
    return sum(weights)
```

**Time Complexity:** O(n × S) where n = length of weights, S = sum(weights) - max(weights)
- Outer loop: S iterations
- can_ship check: O(n) per iteration

**Space Complexity:** O(1)

**Why it's inefficient:** We're checking capacities sequentially. With weights up to 500 and arrays up to 50,000 elements, the sum could be 25,000,000. That's millions of unnecessary checks.

## Optimized Approach: Binary Search on Answer Space

**Core Insight:** The relationship between capacity and feasibility is monotonic. If capacity 15 works, then 16, 17, 18... all work too. This creates a sorted pattern: [doesn't work, doesn't work, ..., works, works, works]. We're looking for the first "works" which is a classic binary search problem.

**Search Space Boundaries:**

1. **Lower bound = max(weights):** We must fit the heaviest package. Any capacity less than this is impossible.
2. **Upper bound = sum(weights):** If we can carry everything in one trip, that's the maximum we'd ever need.

**The Binary Search:**

Instead of searching for a specific value in an array, we're searching for the minimum capacity in the range [max, sum] that allows us to ship within `days` days.
```
Capacity:     5   6   7   8   9   10  11  12  13  14  15  16  17 ...
Can ship?     ✗   ✗   ✗   ✗   ✗   ✗   ✗   ✗   ✗   ✗   ✓   ✓   ✓  ...
                                                   ^
                                                   Find this first ✓
```

**Verification Function (can_ship):**

For a given capacity, simulate the shipping process:
1. Start with day 1, current load = 0
2. For each package in order:
   - If adding it exceeds capacity: start a new day, reset load
   - Add the package to current load
3. Return whether we used ≤ days

**Time Complexity:** O(n × log S) where S = sum(weights) - max(weights)
- Binary search: O(log S) iterations
- can_ship check: O(n) per iteration

**Space Complexity:** O(1)

**Optimization gained:** Reduced from S iterations to log S iterations. For large sums, this is the difference between millions of checks and about 20-30 checks.

## Implementation Walkthrough
```python
def shipWithinDays(self, weights: List[int], days: int) -> int:
    # Define search space
    l, r = max(weights), sum(weights)
    res = r  # Track the minimum capacity found
    
    # Helper function: can we ship with this capacity?
    def canShip(cap: int) -> bool:
        ships = 1       # Start with day 1
        currCap = cap   # Current remaining capacity for this day
        
        for w in weights:
            if currCap - w < 0:  # Can't fit this package
                ships += 1        # Start a new day
                currCap = cap     # Reset capacity
            currCap -= w          # Load the package
        
        return ships <= days
    
    # Binary search for minimum capacity
    while l <= r:
        cap = (l + r) // 2
        
        if canShip(cap):
            res = min(res, cap)  # Found a working capacity
            r = cap - 1          # Try to find smaller
        else:
            l = cap + 1          # Need larger capacity
    
    return res
```

## Step-by-Step Example

**Input:** `weights = [1,2,3,4,5,6,7,8,9,10]`, `days = 5`

**Search Space:** [10, 55]

**Iteration 1:**
- mid = (10 + 55) // 2 = 32
- canShip(32)? Simulate: Day 1: 1+2+3+4+5+6+7+8 = 36 > 32, so actually: 1+2+3+4+5+6+7 = 28, Day 2: 8+9+10 = 27. Only 2 days needed. ✓
- Update: res = 32, r = 31

**Iteration 2:**
- mid = (10 + 31) // 2 = 20
- canShip(20)? Day 1: 1+2+3+4+5 = 15, Day 2: 6+7 = 13, Day 3: 8+9 = 17, Day 4: 10. Only 4 days. ✓
- Update: res = 20, r = 19

**Iteration 3:**
- mid = (10 + 19) // 2 = 14
- canShip(14)? Day 1: 1+2+3+4 = 10, Day 2: 5+6 = 11, Day 3: 7, Day 4: 8, Day 5: 9, Day 6: 10. Needs 6 days. ✗
- Update: l = 15

**Iteration 4:**
- mid = (15 + 19) // 2 = 17
- canShip(17)? Day 1: 1+2+3+4+5 = 15, Day 2: 6+7 = 13, Day 3: 8+9 = 17, Day 4: 10. Only 4 days. ✓
- Update: res = 17, r = 16

**Iteration 5:**
- mid = (15 + 16) // 2 = 15
- canShip(15)? Day 1: 1+2+3+4+5 = 15, Day 2: 6+7 = 13, Day 3: 8, Day 4: 9, Day 5: 10. Exactly 5 days. ✓
- Update: res = 15, r = 14

**Iteration 6:**
- l = 15, r = 14, loop ends

**Result:** 15

## Edge Cases and Testing

1. **Single day:** `weights = [1,2,3]`, `days = 1` → Must carry all at once → `sum(weights) = 6`
2. **Days equal to packages:** `weights = [1,2,3]`, `days = 3` → One package per day → `max(weights) = 3`
3. **All weights equal:** `weights = [5,5,5,5]`, `days = 2` → `capacity = 10` (two packages per day)
4. **Single heavy package:** `weights = [10,1,1,1]`, `days = 2` → `capacity = 10` (can't split the heavy one)

## Common Mistakes

1. **Setting wrong lower bound:** Using 1 or 0 instead of `max(weights)`. This leads to impossible capacities.
2. **Forgetting order constraint:** Trying to sort or rearrange packages. They must be shipped in given order.
3. **Off-by-one in canShip:** Starting with `ships = 0` instead of `ships = 1`, or checking `currCap < w` instead of `currCap - w < 0`.
4. **Not updating result:** Forgetting to track the minimum capacity found, only returning the final `l` or `r` value.

## Pattern Recognition Checklist

When you see a problem asking for "minimum/maximum value that satisfies condition":

1. Can you define a range [min, max] for the answer?
2. Is there a monotonic property? (If X works, does X+1 or X-1 also work?)
3. Can you verify if a candidate answer works in reasonable time?

If yes to all three → Binary search on answer space.

**The template:**
```python
def binary_search_answer(input_data, constraint):
    left = minimum_possible_answer
    right = maximum_possible_answer
    result = right
    
    while left <= right:
        mid = (left + right) // 2
        if is_valid(mid, input_data, constraint):
            result = mid
            # Try to find better (smaller for min, larger for max)
            right = mid - 1  # or left = mid + 1 for maximization
        else:
            left = mid + 1   # or right = mid - 1 for maximization
    
    return result
```

## Key Takeaways

1. **Binary search isn't just for sorted arrays.** It works on any monotonic space, including ranges of possible answers.
2. **The search space comes from problem constraints,** not from input data. Here it's [max_weight, sum_weights].
3. **The verification function is problem-specific.** For this problem, it's simulating the shipping process.
4. **Time complexity improvement is dramatic:** From linear scan O(S) to binary search O(log S).
5. **This pattern appears frequently** in capacity/allocation/distribution problems where you're optimizing a threshold.