# 184. Department Highest Salary

## Solution 1: Three-way join

```sql
SELECT
    e.name AS Employee,
    e.salary AS Salary,
    d.name AS Department
FROM Employee e
INNER JOIN Department d ON e.departmentId = d.id
JOIN (
    SELECT departmentId, MAX(salary) as MaxSalary
    FROM Employee
    GROUP BY departmentID
) m ON e.departmentId = m.departmentId
    AND e.salary = m.MaxSalary;
```

**How This Solution Works**

The query uses a three-way join strategy:

**Step 1: Find max salary per department (subquery `m`)**
```sql
SELECT departmentId, MAX(salary) AS MaxSalary
FROM Employee
GROUP BY departmentId
```
This creates a temporary result set with each department's highest salary.

**Step 2: Join everything together**
- `Employee e` - the base table with all employees
- `INNER JOIN Department d` - gets department names
- `JOIN ... m` - joins with the max salary subquery on TWO conditions:
  - Same department (`e.departmentId = m.departmentId`)
  - Employee's salary equals that department's max (`e.salary = m.MaxSalary`)

**Result:** Only employees whose salary matches their department's maximum pass through both join conditions.

**Key insight:** The double condition in the third join (`departmentId` match AND `salary` match) acts as a filter to keep only the highest-paid employees per department.

**Example trace:**
- Jim (dept 1, salary 90000) → dept 1 max is 90000 → ✓ included
- Joe (dept 1, salary 70000) → dept 1 max is 90000 → ✗ filtered out
- Henry (dept 2, salary 80000) → dept 2 max is 80000 → ✓ included

## Solution 2: Window function with DENSE_RANK

```sql
WITH RankedEmployees AS (
    SELECT
        e.name AS Employee,
        e.salary AS Salary,
        d.name AS Department,
        DENSE_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS salary_rank
    FROM Employee e
    INNER JOIN Department d ON e.departmentId = d.id
)
SELECT Department, Employee, Salary
FROM RankedEmployees
WHERE salary_rank = 1;
```

**How it works:**

1. **`PARTITION BY e.departmentId`** - Creates separate ranking groups for each department
2. **`ORDER BY e.salary DESC`** - Within each department, ranks by salary (highest first)
3. **`DENSE_RANK()`** - Assigns rank 1 to highest salary(ies), rank 2 to next, etc.
   - Multiple employees with same salary get same rank
   - No gaps in ranking (that's why DENSE_RANK, not RANK)
4. **`WHERE salary_rank = 1`** - Filters to keep only the highest-paid in each department

**Visual example:**
```
Before filtering (with ranks):
Department | Employee | Salary | salary_rank
-----------+----------+--------+------------
IT         | Jim      | 90000  | 1
IT         | Max      | 90000  | 1  ← tied for 1st
IT         | Joe      | 70000  | 2
Sales      | Henry    | 80000  | 1
Sales      | Sam      | 60000  | 2

After WHERE salary_rank = 1:
Department | Employee | Salary
-----------+----------+--------
IT         | Jim      | 90000
IT         | Max      | 90000
Sales      | Henry    | 80000
```

Why DENSE_RANK vs RANK vs ROW_NUMBER:

- DENSE_RANK() - Ties get same rank, no gaps (1,1,2,3)
- RANK() - Ties get same rank, with gaps (1,1,3,4)
- ROW_NUMBER() - No ties, arbitrary ordering (1,2,3,4)

For this problem, DENSE_RANK() is correct because we want all employees with the max salary.
