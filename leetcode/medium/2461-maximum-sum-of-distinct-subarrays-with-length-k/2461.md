# Maximum Sum of Distinct Subarrays with Length K

## Problem

Find the maximum sum of any k-length subarray where all elements are distinct.

Constraints:

1 <= k <= nums.length <= 105
1 <= nums[i] <= 105

## Idea

Use sliding window with the frequency map.

Instead of checking every k-length subarray from scratch, maintain a window that slides through the array one element at a time. Track both the sum and element frequencies incrementally.

## Why it works

The frequency map serves one purpose: detect duplicates efficiently.

- Map size equals k => all elements are distinct (each appears exactly once)
- Map size less than k => duplicates exist (some element appears multiple times)

The sliding window avoids redundant work:

- When moving from `[i, i+k-1]` to `[i+1, i+k]`, only two elements change
- Remove left element: subtract from sum, decrement its frequency
- Add right element: add to sum, increment its frequency
- No need to recalculate the entire window

## Implementation

- Build first window: sum first `k` elements, populate frequency map
- Check validity: if map size equals `k`, all elements are distinct
- Slide window: for each remaining element:
  - Remove leftmost element from window (update sum and frequency)
  - Add new rightmost element to window (update sum and frequency)
  - If map size equals k, consider this sum as a candidate for maximum

Key: the max size check `freq.size === k` is the distinctness test. When a duplicate enters the window, one element's count becomes 2+, reducing the map size below `k`. When we remove that duplicate, count drops back to 1, but map size remains the same until it's fully removed.

## Complexity

- Time: O(n) - single pass through array
- Space: O(k) - frequency map stores at most k elements

## Pattern

Use this approach when:

- Fixed-size window constraint
- Need to track elements uniqueness or frequency
- Want to avoid recalculating overlapping data

## Code

```ts
function maximumSubarraySum(nums: number[], k: number): number {
  let maxSum = 0;
  let currentSum = 0;
  const freq = new Map<number, number>();

  // first window
  for (let i = 0; i < k; i++) {
    currentSum += nums[i];
    const currentCount = freq.get(nums[i]) || 0;
    freq.set(nums[i], currentCount + 1);
  }

  // check if first window is valid (all distinct)
  if (freq.size === k) {
    maxSum = currentSum;
  }

  // slide the window

  for (let i = k; i < nums.length; i++) {
    // remove leftmost element of prev window
    const leftNum = nums[i - k];
    currentSum -= leftNum;
    const leftCount = freq.get(leftNum) || 0;
    if (leftCount === 1) {
      freq.delete(leftNum);
    } else {
      freq.set(leftNum, leftCount - 1);
    }

    // add new rightmost element
    const rightNum = nums[i];
    currentSum += rightNum;
    const rightCount = freq.get(rightNum) || 0;
    freq.set(rightNum, rightCount + 1);

    // if current window is valid
    if (freq.size === k) {
      maxSum = Math.max(maxSum, currentSum);
    }
  }

  return maxSum;
}
```
