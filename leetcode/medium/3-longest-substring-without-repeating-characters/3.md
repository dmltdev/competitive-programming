# Longest Substring Without Repeating Characters

## Problem

Given a string `s`, find the length of the longest substring without duplicate characters.

Example 1:

- Input: s = "abcabcbb"
- Output: 3
- Explanation: The answer is "abc", with the length of 3.

Example 2:

- Input: s = "bbbbb"
- Output: 1
- Explanation: The answer is "b", with the length of 1.

Example 3:

- Input: s = "pwwkew"
- Output: 3
- Explanation: The answer is "wke", with the length of 3.

## Idea

Expand the window by moving `right` pointer until a duplicate is found. When a duplicate appears, shrink the window from the left until the duplicate is removed. Track the maximum window size seen.

The set tracks characters in the current window:

- If `s[right]` is not in the set => window is still valid, expand it
- If `s[right]` is in the set => duplicate found, shrink from left until duplicate is removed

The two-pointer technique ensures:

- Each character is added at most once (when `right` moves)
- Each character is removed at most once (when `left` moves)
- Total operations: O(2n) = O(n)

To conclude, this window grows and shrinks dynamically:

- Expand by moving `right` when condition is satisfied (no duplicate)
- Shrink by move `left` when condition is violated (duplicate found)
- Update answer when expanding window to the right

### Implementation

```typescript
function lengthOfLongestSubstring(s: string): number {
  let left = 0;
  let right = 0;
  let max = 0;
  const set = new Set<string>();

  while (right < s.length) {
    if (set.has(s[right])) {
      // is a duplicate, shrink window from the left
      set.delete(s[left++]);
    } else {
      // not a duplicate, expand window to the right
      set.add(s[right++]);
      max = Math.max(max, set.size);
    }
  }

  return max;
}
```

**Complexity**: O(n) time, O(min(n, m)) space where m is the character set size
