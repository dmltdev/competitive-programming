# 49. Group Anagrams

## Description

Given an array of strings strs, group the anagrams together. You can return the answer in any order.

## Example 1

Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
Explanation:

- There is no string in strs that can be rearranged to form "bat".
- The strings "nat" and "tan" are anagrams as they can be rearranged to form each other.
- The strings "ate", "eat", and "tea" are anagrams as they can be rearranged to form each other.

## Example 2

Input: strs = [""]
Output: [[""]]

## Example 3

Input: strs = ["a"]
Output: [["a"]]

## Constraints

- 1 <= strs.length <= 10^4
- 0 <= strs[i].length <= 100
- strs[i] consists of lowercase English letters.

## Solution

### Idea

Anagrams have the same characters in different order. We need a way to identify same characters so we can group them together.
For that, we can create a unique signature (key) for each anagram group, then use a hash map to collect strings with matching signatures.

The hash map automatically handles the grouping:

- First occurrence of a signature creates a new group
- Each subsequent match adds to the existing group
- Different signatures create separate groups
- Extracting map values gives us the final grouped result

### Solution 1: Sorted string as unique key

- Sort each string alphabetically
- Sorted strings become identical for anagrams
- Use sorted string as hash map key
- All strings that produce the same sorted key get grouped together.

Sorting is deterministic: any two strings with the same characters will produce identical sorted strings, regardless of original order.

Complexity:

- Time: O(n \* k log k), - sort each of n strings of length k
- Space: O(n \* k) => store all n strings of length k

```ts
function groupAnagrams_(strs: string[]): string[][] {
  const groups = new Map<string, string[]>();

  for (const str of strs) {
    // signature: sorted characters
    const key = str.split("").sort().join("");

    if (!groups.has(key)) {
      // new group
      groups.set(key, []);
    }
    // group of anagrams exists, add new string to it
    groups.get(key)!.push(str);
  }

  return Array.from(groups.values());
}
```

### Solution 2: Character frequency as unique key

- Count frequency of each character
- Convert counts to a string
- Use count string as hash map key
- Strings with identical character counts get grouped together

Character frequency is another deterministic way to identify same characters. Two strings are anagrams if and only if they have the same character counts.

*Note: we use array of size 26 to count character frequencies, since there are 26 lowercase English letters.*
*Note: we deduct 97 from char code to get zero-based index. Char code of 'a' is 97, so 'a' - 97 = 0, 'b' - 97 = 1, etc.*

```ts
function groupAnagrams(strs: string[]): string[][] {
  const groups = new Map<string, string[]>();

  for (const str of strs) {
    const counts = new Array(26).fill(0);
    for (const char of str) {
      counts[char.charCodeAt(0) - 97]++;
    }

    // signature: character counts joined by comma to form a string
    const key = counts.join(",");
    if (!groups.has(key)) {
      // new group
      groups.set(key, []);
    }
    // group of anagrams exists, add new string to it
    groups.get(key)!.push(str);
  }

  return Array.from(groups.values());
}
```

Complexity:

- Time: O(n \* k) - scan each character once
- Space: O(n \* k) => store all strings
