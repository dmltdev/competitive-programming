# Maximum Subarray

## Problem

Given an integer array `nums`, find the subarray with the largest sum, and return its sum.

Example 1:

- Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
- Output: 6
- Explanation: The subarray [4,-1,2,1] has the largest sum 6.

Example 2:

- Input: nums = [1]
- Output: 1
- Explanation: The subarray [1] has the largest sum 1.

Example 3:

- Input: nums = [5,4,-1,7,8]
- Output: 23
- Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.

Constraints:

- 1 <= nums.length <= 105
- -104 <= nums[i] <= 104

Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

## Solution 1: Reset When Negative

Track the max sum ending at each position. If the running sum becomes negative, reset it to zero because any negative sum will only decrease future totals.

The important part is that a negative running sum is worthless:

- If `currSum < 0`, starting fresh from the next element gives a better result
- If `currSum >= 0`, keep adding to it - even adding negative numbers might lead to a larger total later

The algorithm maintains two values:

- `currSum`, best sum ending at current position
- `maxSum`, best sum seen across all positions

```ts
function maxSubArray(nums: number[]): number {
  let maxSum: number = nums[0];
  let currSum = 0;

  for (let i = 0; i < nums.length; i++) {
    if (currSum < 0) {
      currSum = 0;
    }

    currSum += nums[i];
    maxSum = Math.max(maxSum, currSum);
  }

  return maxSum;
}
```

**Complexity**: O(n) time, O(1) space

## Solution 2: Kadane's Algorithm

At each position, decide: should I extend the previous subarray or start a new one?

The decision is explicit: `Math.max(nums[i], currentSum + nums[i])`

- If `currentSum + nums[i] < nums[i]`, that means `currentSum` is less than 0, so start fresh
- Otherwise, extending the previous sum is better

This is the textbook formulation of Kadane's algorithm - a greedy dynamic programming approach where the state at position `i` is maximum sum ending at position `i`

```ts
function maxSubArray(nums: number[]): number {
  let maxSum = nums[0];
  let currentSum = nums[0];

  for (let i = 1; i < nums.length; i++) {
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
  }

  return maxSum;
}
```

**Complexity**: O(n) time, O(1) space

### Conclusion

Solution 2 is better than solution 1: it is more aligned with how the algorithm is typically taught, though both are equally valid. Solution 1 is a two-step process when we have to reset if negative and then add, while solution 2 has a single decision - extend or restart.