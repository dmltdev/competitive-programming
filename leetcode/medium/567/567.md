# Permutation in string

## Sliding Window

- Window size is fixed at `s1.length`
- At each step, remove leftmost character and add new rightmost character
- Only update the frequency counts for characters that changed

## Matches optimization

Instead of comparing all 26 frequencies at each window position (O(26) per window), we track how many frequencies currently match and only update match count when adding/removing characters (O(1) per window)

## Solution

```ts
function checkInclusion(s1: string, s2: string): boolean {
  if (s1.length > s2.length) return false;

  const freq1: number[] = new Array(26).fill(0);
  const freq2: number[] = new Array(26).fill(0);
  const aCode = "a".charCodeAt(0);

  for (let i = 0; i < s1.length; i++) {
    freq1[s1.charCodeAt(i) - aCode]++;
    freq2[s2.charCodeAt(i) - aCode]++;
  }

  let matches = 0;
  for (let i = 0; i < 26; i++) {
    if (freq1[i] === freq2[i]) matches++;
  }

  if (matches === 26) return true;

  for (let i = s1.length; i < s2.length; i++) {
    const rightChar = s2.charCodeAt(i) - aCode;
    freq2[rightChar]++;

    if (freq2[rightChar] === freq1[rightChar]) {
      matches++;
    } else if (freq2[rightChar] === freq1[rightChar] + 1) {
      matches--;
    }

    const leftChar = s2.charCodeAt(i - s1.length) - aCode;
    freq2[leftChar]--;

    if (freq2[leftChar] === freq1[leftChar]) {
      matches++;
    } else if (freq2[leftChar] === freq1[leftChar] - 1) {
      matches--;
    }

    if (matches === 26) return true;
  }

  return false;
}
```