# Binary Tree Preorder Traversal

## Problem

Given the root of a binary tree, return the preorder traversal of its nodes' values.

Preorder traversal visits nodes in this order: current node => left subtree => right subtree

## Algorithm

### Recursive Approach

The natural solution uses recursion to mirror the tree's recursive structure:

- If node is null, return
- Process current node (add value to result)
- Recursively traverse left subtree
- Recursively traverse right subtree
- Return result

Complexity:

- Time: O(n), where n is the number of nodes in the tree - we visit each node once
- Space: O(h), where h is the height of the tree - recursion call stack depth equals tree height

## Iterative Approach

The iterative solution uses an explicit stack to simulate recursion:

- If the root is null, return empty array
- Push root onto stack
- While stack is not empty:
  - Pop node and add value to result
  - Push right child onto stack (if exists)
  - Push left child onto stack (if exists)
- Return result

Key Note: Push right child before left child. Since stacks are LIFO (last in, first our), this ensures left child is processed before right child.

Complexity:

- Time: O(n), where n is the number of nodes in the tree - we visit each node once
- Space: O(h), where h is the height of the tree - stack depth equals tree height

## Recursive vs Iterative

Recursive:

- Simpler, more readable code
- Use when recursion depth won't cause stack overflow
- Natural fit for tree problems

Iterative:

- Avoids recursion overhead
- Required when recursion depth might be very large
- Demonstrates understanding of stack-based DFS
